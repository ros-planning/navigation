#!/usr/bin/env python
# DWA Planner configuration

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t
from local_planner_limits import add_generic_localplanner_params

gen = ParameterGenerator()


# This unusual line allows to reuse existing parameter definitions
# that concern all localplanners
add_generic_localplanner_params(gen)

gen.add("sim_time", double_t, 0, "The amount of time to roll trajectories out for in seconds", 1.7, 0)
gen.add("sim_granularity", double_t, 0, "The granularity with which to check for collisions along each trajectory in meters", 0.025, 0)
gen.add("angular_sim_granularity", double_t, 0, "The granularity with which to check for collisions for rotations in radians", 0.1, 0)

gen.add("path_distance_bias", double_t, 0, "The weight for the path distance part of the cost function", 32.0, 0.0)
gen.add("goal_distance_bias", double_t, 0, "The weight for the goal distance part of the cost function", 24.0, 0.0)
gen.add("occdist_scale", double_t, 0, "The weight for the obstacle distance part of the cost function", 0.01, 0.0)
gen.add("velocity_scale", double_t, 0, "The weight for the velocity part of the cost function", 0.01, 0.0)
gen.add("jerk_scale", double_t, 0, "The weight for the jerk part of the cost function", 0.01, 0, 5)
gen.add("euclidean_distance_scale", double_t, 0, "The weight for the euclidean distance part of the cost function", 1.0, 0, 5)
gen.add("heading_critic_capture_min_radius", double_t, 0, "The minimum capture radius for the heading cost function", 0.25, 0, 5)
gen.add("heading_critic_capture_max_radius", double_t, 0, "The maximum capture radius of the heading cost function", 1.0, 0, 5)
gen.add("heading_critic_half_angle", double_t, 0, "The half angle used to reject trajectories in the heading cost function", 1.57, 0, 5)
gen.add("max_allowed_distance_from_global_plan", double_t, 0, "The maximum distance the global plan is allowed to be from the robot", 1.0, 0, 5)

gen.add("stop_time_buffer", double_t, 0, "The amount of time that the robot must stop before a collision in order for a trajectory to be considered valid in seconds", 0.2, 0)
gen.add("oscillation_reset_dist", double_t, 0, "The distance the robot must travel before oscillation flags are reset, in meters", 0.05, 0)
gen.add("oscillation_reset_angle", double_t, 0, "The angle the robot must turn before oscillation flags are reset, in radians", 0.2, 0)
gen.add("oscillation_reset_plan_divergence_distance", double_t, 0, "The distance two plans must diverge within to reset oscilation flags for a new plan", 1.0, 0)

gen.add("forward_point_distance", double_t, 0, "The distance from the center point of the robot to place an additional scoring point, in meters", 0.325)
gen.add("close_to_goal_range", double_t, 0, "The range at which the robot switches to a 'close to goal' mode and ignores foward projection critics", 1.5, 0, 10);

gen.add("scaling_speed", double_t, 0, "The absolute value of the velocity at which to start scaling the robot's footprint, in m/s", 0.25, 0)
gen.add("max_scaling_factor", double_t, 0, "The maximum factor to scale the robot's footprint by", 0.2, 0)

gen.add("minimum_simulation_time_factor", double_t, 0, "The minimum simulation time scale factor", 0.25, 0)

gen.add("min_slow_vel_x", double_t, 0, "The minimum desired x velocity for the robot in m/s", 0.3, 0, 1.0)
gen.add("speed_cost_half_angle", double_t, 0, "The half angle in which to consider obstructions for speed limits", 1.5, 0, 3.2)
gen.add("speed_cost_y_buffer", double_t, 0, "The minimum buffer in the robot's y axis to add for slowing down.", 0.3, 0, 1.0)
gen.add("speed_cost_x_buffer", double_t, 0, "The minimum buffer in the robot's x axis to add for slowing down.", 0.5, 0, 2.0)
gen.add("min_slow_angular_vel", double_t, 0, "The minimum desired x velocity for the robot in rad/s.", 0.6, 0, 2.0)
gen.add("speed_cost_min_angular_vel_effect_dist", double_t, 0, "The minimum range beyond the circumscribed readius to add for slowing down.", 0.2, 0, 2.0)
gen.add("speed_cost_max_angular_vel_effect_dist", double_t, 0, "The maximum range beyond the circumscribed readius to add for slowing down.", 0.5, 0, 2.0)

gen.add("shadow_speed_limit_min_slow_vel_x", double_t, 0, "The minimum desired x velocity for the robot in m/s", 0.3, 0, 1.0)
gen.add("shadow_speed_limit_max_effective_range", double_t, 0, "The maximum range that shadows effect the robot", 2.5, 0, 3.0)
gen.add("shadow_speed_limit_min_effective_range", double_t, 0, "The minimum range that shadows effect the robot", 1.25, 0, 3.0)
gen.add("shadow_speed_limit_forward_offset", double_t, 0, "The amount forwards from the robot origin to measure distances from", 0.5, -1.5, 1.5)

gen.add("vx_samples", int_t, 0, "The number of samples to use when exploring the x velocity space", 3, 1)
gen.add("vy_samples", int_t, 0, "The number of samples to use when exploring the y velocity space", 10, 1)
gen.add("vth_samples", int_t, 0, "The number of samples to use when exploring the theta velocity space", 20, 1)

gen.add("use_dwa", bool_t, 0, "Use dynamic window approach to constrain sampling velocities to small window.", True)

gen.add("restore_defaults", bool_t, 0, "Restore to the original configuration.", False)

gen.add("follower_generator_kp_theta", double_t, 0, "Controller constant for the follower trajectory generator", 3.25, 0, 100)
gen.add("follower_generator_lookahead_distance", double_t, 0, "Controller lookahead distance for the follower trajectory generator", 0.5, 0, 10)
gen.add("follower_generator_num_trajectories", int_t, 0, "Number of trajectories by the follower trajecotry generator", 2, 0, 20)
gen.add("tip_generator_num_trajectories", int_t, 0, "Number of trajectories by the tip trajectory generator", 4, 0, 20)
gen.add("tip_sim_time", double_t, 0, "The amount of time to roll tip trajectories out for in seconds", 4.0, 0)


gen.add("always_use_euclidean_goal_distance", bool_t, 0, "Always use the euclidean critic for goal distance, even when the robot is not close to the goal.", False)
gen.add("enable_simple_trajectory_generator", bool_t, 0, "Use the standard trajectory generator.", True)
gen.add("enable_follower_trajectory_generator", bool_t, 0, "Use the follower trajectory generator.", False)
gen.add("enable_stationary_trajectory_generator", bool_t, 0, "Use the stationary_trajectory_generator.", False)
gen.add("enable_tip_trajectory_generator", bool_t, 0, "Use the tip_trajectory_generator.", True)

gen.add("publish_traj_pc", bool_t, 0, "Publish the debug point cloud.", True)

exit(gen.generate("dwa_local_planner", "dwa_local_planner", "DWAPlanner"))
